%PDF-1.3
%ºß¬à
3 0 obj
<</Type /Page
/Parent 1 0 R
/Resources 2 0 R
/MediaBox [0 0 595.2799999999999727 841.8899999999999864]
/Contents 4 0 R
>>
endobj
4 0 obj
<<
/Length 15765
>>
stream
0.5670000000000001 w
0 G
BT
/F9 10 Tf
11.5 TL
0 g
28.3464566929133888 813.5435433070865656 Td
(Alfredo: Explica el siguiente código línea a línea) Tj
T* () Tj
T* (from qiskit import *) Tj
T* (from qiskit.visualization import plot_histogram) Tj
T* (from qiskit.circuit.library import MCXGate) Tj
T* () Tj
T* (def state_A\(\):) Tj
T* (    qc = QuantumCircuit\(8\)) Tj
T* (    qc.x\(2\)) Tj
T* (    qc.x\(3\)) Tj
T* (    qc.x\(4\)) Tj
T* (    qc.x\(7\)) Tj
T* (    return qc) Tj
T* () Tj
T* (def reglas\(nombre:str,tamaño:int, bandera:int, rastro:tuple, descriptor:int\) -> QuantumCircuit:) Tj
T* (    qc = QuantumCircuit\(tamaño\)) Tj
T* (    qc.ccx\(0,1,rastro[0]\)) Tj
T* (    qc.ccx\(2,3,rastro[1]\)) Tj
T* (    qc.ccx\(4,5,rastro[2]\)) Tj
T* (    qc.ccx\(6,7,rastro[3]\)) Tj
T* (    qc.ccx\(rastro[0],descriptor,bandera\)) Tj
T* (    qc.cswap\(bandera,0,4\)) Tj
T* (    qc.cswap\(bandera,1,5\)) Tj
T* (    qc.ccx\(rastro[0],descriptor,bandera\)) Tj
T* (    qc.x\(descriptor\)) Tj
T* (    qc.ccx\(rastro[0],descriptor,bandera\)) Tj
T* (    qc.cswap\(bandera,0,2\)) Tj
T* (    qc.cswap\(bandera,1,3\)) Tj
T* (    qc.ccx\(rastro[0],descriptor,bandera\)) Tj
T* (    qc.x\(descriptor\)) Tj
T* (    qc.barrier\(\)) Tj
T* (    qc.ccx\(rastro[1],descriptor,bandera\)) Tj
T* (    qc.cswap\(bandera,0,2\)) Tj
T* (    qc.cswap\(bandera,1,3\)) Tj
T* (    qc.ccx\(rastro[1],descriptor,bandera\)) Tj
T* (    qc.x\(descriptor\)) Tj
T* (    qc.ccx\(rastro[1],descriptor,bandera\)) Tj
T* (    qc.cswap\(bandera,2,6\)) Tj
T* (    qc.cswap\(bandera,3,7\)) Tj
T* (    qc.ccx\(rastro[1],descriptor,bandera\)) Tj
T* (    qc.x\(descriptor\)) Tj
T* (    qc.barrier\(\)) Tj
T* (    qc.ccx\(rastro[2],descriptor,bandera\)) Tj
T* (    qc.cswap\(bandera,4,6\)) Tj
T* (    qc.cswap\(bandera,5,7\)) Tj
T* (    qc.ccx\(rastro[2],descriptor,bandera\)) Tj
T* (    qc.x\(descriptor\)) Tj
T* (    qc.ccx\(rastro[2],descriptor,bandera\)) Tj
T* (    qc.cswap\(bandera,0,4\)) Tj
T* (    qc.cswap\(bandera,1,5\)) Tj
T* (    qc.ccx\(rastro[2],descriptor,bandera\)) Tj
T* (    qc.x\(descriptor\)) Tj
T* (    qc.barrier\(\)) Tj
T* (    qc.ccx\(rastro[3],descriptor,bandera\)) Tj
T* (    qc.cswap\(bandera,2,6\)) Tj
T* (    qc.cswap\(bandera,3,7\)) Tj
T* (    qc.ccx\(rastro[3],descriptor,bandera\)) Tj
T* (    qc.x\(descriptor\)) Tj
T* (    qc.ccx\(rastro[3],descriptor,bandera\)) Tj
T* (    qc.cswap\(bandera,4,6\)) Tj
T* (    qc.cswap\(bandera,5,7\)) Tj
T* (    qc.ccx\(rastro[3],descriptor,bandera\)) Tj
T* (    qc.x\(descriptor\)) Tj
T* (    qc.barrier\(\)) Tj
T* (    qc.name = nombre) Tj
T* (    return qc) Tj
T* () Tj
T* (Chatsonic: La primera línea importa todas las librerías necesarias de Qiskit, incluyendo QuantumCircuit, plot_histogram y) Tj
T* (MCXGate. [1]) Tj
T* () Tj
T* (La función "state_A" crea un circuito cuántico de 8 qubits y aplica una compuerta X a los qubits en las posiciones 2, 3, 4 y 7.) Tj
T* (Luego retorna el circuito. ) Tj
T* () Tj
T* (La función "reglas" toma varios argumentos, incluyendo un nombre para el circuito, el tamaño del circuito, una bandera, un) Tj
T* (rastro y un descriptor. La función crea un circuito cuántico de tamaño especificado y aplica una serie de compuertas CCX y) Tj
T* (CSwap a los qubits del circuito basándose en las reglas especificadas. El circuito resultante es nombrado con el nombre) Tj
T* (especificado y es retornado por la función. ) Tj
T* () Tj
T* (En resumen, el código importa las librerías necesarias de Qiskit, define dos funciones que crean circuitos cuánticos con) Tj
T* (compuertas específicas aplicadas en ciertas posiciones y crea un conjunto de reglas para aplicar a los qubits en un circuito.) Tj
T* () Tj
T* (<b>References:</b>) Tj
T* (<span>[1] <a href='https://qiskit.org/documentation/stubs/qiskit.visualization.plot_histogram.html' target='_blank') Tj
T* (class='text-purple-1 underline'>qiskit.visualization.plot_histogram</a></span>) Tj
T* (<span>[2] <a href='https://qiskit.org/documentation/tutorials/circuits_advanced/03_advanced_circuit_visualization.html') Tj
T* (target='_blank' class='text-purple-1 underline'>Visualizing a Quantum Circuit - Qiskit</a></span>) Tj
T* (<span>[3] <a href='https://qiskit.org/documentation/tutorials/circuits/2_plotting_data_in_qiskit.html' target='_blank') Tj
T* (class='text-purple-1 underline'>Qiskit Visualizations</a></span>) Tj
T* () Tj
T* () Tj
T* (Alfredo: tomando en cuenta el codigo anterior explica detalladamente linea a linea este segmento de codigo) Tj
T* () Tj
T* (def oracle\(size\):) Tj
T* (    qc = QuantumCircuit\(size\)) Tj
T* (    gate = MCXGate\(4\)) Tj
T* (    qc.append\(gate,[0, 1, 4, 7, size-1]\)) Tj
T* (    qc.name="O") Tj
T* (    return qc) Tj
T* (    ) Tj
T* (def reglas_inv\(nombre:str, tamaño:int, bandera:int, rastro:tuple, descriptor:int\) -> QuantumCircuit:) Tj
T* (    qc = reglas\(nombre, tamaño, bandera, rastro, descriptor\)) Tj
T* (    qc_inv = qc.inverse\(\)) Tj
T* (    qc_inv.name = nombre + "_inv") Tj
T* (    return qc_inv) Tj
T* (    ) Tj
T* (def Grover3\(\):) Tj
T* (    qc = QuantumCircuit\(24\)) Tj
T* (    qc.h\([13,18,23]\)) Tj
T* (    qc.x\([13,18,23]\)) Tj
T* (    qc.h\(13\)) Tj
T* (    qc.ccx\(18,23,13\)) Tj
T* (    qc.h\(13\)) Tj
T* (    qc.x\([13,18,23]\)) Tj
T* (    qc.h\([13,18,23]\)) Tj
T* (    qc.name="G") Tj
T* (    return qc) Tj
T* (    ) Tj
T* (qc3 = QuantumCircuit\(25\)) Tj
T* (qc3.h\(13\)) Tj
T* (qc3.h\(18\)) Tj
T* (qc3.h\(23\)) Tj
T* (qc3.x\(24\)) Tj
T* (qc3.h\(24\)) Tj
T* (qc3.barrier\(\)) Tj
T* (qc3.append\(state_A\(\),range\(8\)\)) Tj
T* (qc3.append\(reglas\(nombre="R1",tamaño=14,bandera=8,rastro=\(9,10,11,12\),descriptor=13\), range\(14\)\)) Tj
T* (qc3.append\(reglas\(nombre="R2",tamaño=19,bandera=8,rastro=\(14,15,16,17\),descriptor=18\),range\(19\)\)) Tj
T* (qc3.append\(reglas\(nombre="R3",tamaño=24,bandera=8,rastro=\(19,20,21,22\),descriptor=23\),range\(24\)\)) Tj
T* (qc3.append\(oracle\(25\),range\(25\)\)) Tj
T* (qc3.append\(reglas_inv\(nombre="R3",tamaño=24,bandera=8,rastro=\(19,20,21,22\),descriptor=23\),range\(24\)\)) Tj
T* (qc3.append\(reglas_inv\(nombre="R2",tamaño=19,bandera=8,rastro=\(14,15,16,17\),descriptor=18\),range\(19\)\)) Tj
T* (qc3.append\(reglas_inv\(nombre="R1",tamaño=14,bandera=8,rastro=\(9,10,11,12\),descriptor=13\), range\(14\)\)) Tj
T* (qc3.append\(state_A\(\),range\(8\)\)) Tj
T* (qc3.barrier\(\)) Tj
T* (qc3.h\(24\)) Tj
T* (qc3.barrier\(\)) Tj
T* (qc3.append\(Grover3\(\),range\(24\)\)) Tj
T* () Tj
T* (Chatsonic: Sorry, we cannot process your request. Please contact the support team.) Tj
T* () Tj
T* (Alfredo: tomando en cuenta el codigo anterior explica detalladamente linea a linea este segmento de codigo) Tj
T* () Tj
T* (def oracle\(size\):) Tj
T* (    qc = QuantumCircuit\(size\)) Tj
T* (    gate = MCXGate\(4\)) Tj
T* (    qc.append\(gate,[0, 1, 4, 7, size-1]\)) Tj
T* (    qc.name="O") Tj
T* (    return qc) Tj
T* (    ) Tj
T* (def reglas_inv\(nombre:str, tamaño:int, bandera:int, rastro:tuple, descriptor:int\) -> QuantumCircuit:) Tj
T* (    qc = reglas\(nombre, tamaño, bandera, rastro, descriptor\)) Tj
T* (    qc_inv = qc.inverse\(\)) Tj
T* (    qc_inv.name = nombre + "_inv") Tj
T* (    return qc_inv) Tj
T* (    ) Tj
T* (def Grover3\(\):) Tj
T* (    qc = QuantumCircuit\(24\)) Tj
T* (    qc.h\([13,18,23]\)) Tj
T* (    qc.x\([13,18,23]\)) Tj
T* (    qc.h\(13\)) Tj
T* (    qc.ccx\(18,23,13\)) Tj
T* (    qc.h\(13\)) Tj
T* (    qc.x\([13,18,23]\)) Tj
T* (    qc.h\([13,18,23]\)) Tj
T* (    qc.name="G") Tj
T* (    return qc) Tj
T* (    ) Tj
T* (qc3 = QuantumCircuit\(25\)) Tj
T* (qc3.h\(13\)) Tj
T* (qc3.h\(18\)) Tj
T* (qc3.h\(23\)) Tj
T* (qc3.x\(24\)) Tj
T* (qc3.h\(24\)) Tj
T* (qc3.barrier\(\)) Tj
T* (qc3.append\(state_A\(\),range\(8\)\)) Tj
T* (qc3.append\(reglas\(nombre="R1",tamaño=14,bandera=8,rastro=\(9,10,11,12\),descriptor=13\), range\(14\)\)) Tj
T* (qc3.append\(reglas\(nombre="R2",tamaño=19,bandera=8,rastro=\(14,15,16,17\),descriptor=18\),range\(19\)\)) Tj
T* (qc3.append\(reglas\(nombre="R3",tamaño=24,bandera=8,rastro=\(19,20,21,22\),descriptor=23\),range\(24\)\)) Tj
T* (qc3.append\(oracle\(25\),range\(25\)\)) Tj
T* (qc3.append\(reglas_inv\(nombre="R3",tamaño=24,bandera=8,rastro=\(19,20,21,22\),descriptor=23\),range\(24\)\)) Tj
T* (qc3.append\(reglas_inv\(nombre="R2",tamaño=19,bandera=8,rastro=\(14,15,16,17\),descriptor=18\),range\(19\)\)) Tj
T* (qc3.append\(reglas_inv\(nombre="R1",tamaño=14,bandera=8,rastro=\(9,10,11,12\),descriptor=13\), range\(14\)\)) Tj
T* (qc3.append\(state_A\(\),range\(8\)\)) Tj
T* (qc3.barrier\(\)) Tj
T* (qc3.h\(24\)) Tj
T* (qc3.barrier\(\)) Tj
T* (qc3.append\(Grover3\(\),range\(24\)\)) Tj
T* () Tj
T* (Chatsonic: La función `oracle\(size\)` se define en las líneas 1-6 y toma como entrada un entero `size`. Se crea una instancia de) Tj
T* (la clase `QuantumCircuit` con un tamaño especificado por `size`. Luego, se crea un objeto de la clase `MCXGate` con cuatro) Tj
T* (controles y un objetivo. Este objeto se añade a la instancia de `QuantumCircuit` en los qubits especificados por `[0, 1, 4, 7,) Tj
T* (size-1]`. Finalmente, se asigna un nombre a la instancia de `QuantumCircuit` y se devuelve.) Tj
T* () Tj
T* (La función `reglas_inv\(nombre:str, tamaño:int, bandera:int, rastro:tuple, descriptor:int\)` se define en las líneas 8-14 y toma) Tj
T* (como entrada una cadena de texto `nombre`, un entero `tamaño`, un entero `bandera`, una tupla `rastro` y un entero) Tj
T* (`descriptor`. Se crea una instancia de `QuantumCircuit` usando los argumentos de entrada en la función `reglas\(nombre,) Tj
T* (tamaño, bandera, rastro, descriptor\)` y se invierte usando el método `inverse\(\)`. Luego se le asigna un nombre a la instancia de) Tj
T* (`QuantumCircuit` y se devuelve.) Tj
T* () Tj
T* (La función `Grover3\(\)` se define en las líneas 16-27 y crea una instancia de `QuantumCircuit` con 24 qubits. Se aplican las) Tj
T* (compuertas Hadamard a los qubits `[13,18,23]`. Luego, se aplica la compuerta X a los mismos qubits. A continuación, se) Tj
T* (aplica la compuerta Hadamard al qubit 13. Se utiliza la compuerta CCX en los qubits `[18,23]` para controlar la compuerta X) Tj
T* (en el qubit 13. Luego, se aplica la compuerta Hadamard al qubit 13. Finalmente, se aplica la compuerta X y la compuerta) Tj
T* (Hadamard a los qubits `[13,18,23]`. Se asigna un nombre a la instancia de `QuantumCircuit` y se devuelve.) Tj
T* () Tj
T* (La instancia de `QuantumCircuit` `qc3` se crea en la línea 29 con 25 qubits. Se aplican las compuertas Hadamard a los qubits) Tj
T* (`[13,18,23]` y la compuerta X al qubit 24. Se agrega una barrera y se agrega la instancia de `QuantumCircuit` `state_A\(\)` a los) Tj
T* (primeros 8 qubits. Luego, se agrega la instancia de `QuantumCircuit`) Tj
T* (`reglas\(nombre="R1",tamaño=14,bandera=8,rastro=\(9,10,11,12\),descriptor=13\)` a los qubits del 0 al 13. Se repite este proceso) Tj
T* (para la instancia de `QuantumCircuit` `reglas\(nombre="R2",tamaño=19,bandera=8,rastro=\(14,15,16,17\),descriptor=18\)` y los) Tj
T* (qubits del 0 al 18 y para la instancia de `QuantumCircuit`) Tj
T* (`reglas\(nombre="R3",tamaño=24,bandera=8,rastro=\(19,20,21,22\),descriptor=23\)` y los qubits del 0 al 23. Luego se agrega la) Tj
T* (instancia de `QuantumCircuit` `oracle\(25\)` a todos los 25 qubits. Se invierten las tres instancias de `QuantumCircuit` `reglas` y) Tj
T* (la instancia de `QuantumCircuit` `state_A\(\)` en el mismo orden en que se agregaron. Luego se agrega otra barrera y se aplica la) Tj
T* (compuerta Hadamard al qubit 24. Finalmente, se agrega la instancia de `QuantumCircuit` `Grover3\(\)` a los primeros 24 qubits.) Tj
T* () Tj
T* (Alfredo: en la funcion oracle especificamente de que sirve MCXGate\(4\), explica puntualmente para que se usa en este y otros) Tj
T* (casos) Tj
T* () Tj
T* (Chatsonic: La compuerta `MCXGate\(4\)` en el contexto de la función oracle puede ser utilizada para aplicar una operación) Tj
T* (controlada en varios qubits a la vez. En este caso, se aplica la compuerta en los qubits 9, 10, 11 y 12, donde el qubit 8 actúa) Tj
T* (como el qubit de control. La compuerta `MCXGate` es una generalización de la compuerta de Toffoli \(también conocida como) Tj
T* (compuerta CCX\) que permite controlar la operación en más de dos qubits. En general, la compuerta `MCXGate` toma como) Tj
T* (entrada una lista de qubits, donde el último qubit es el qubit de destino y los demás son qubits de control. La compuerta opera) Tj
T* (de tal manera que se aplica la operación controlada solo si todos los qubits de control están en el estado |1>. De lo contrario, no) Tj
T* (se aplica la operación. La compuerta `MCXGate` es útil para aplicar operaciones complejas y controladas en varios qubits a la) Tj
T* (vez en circuitos cuánticos.) Tj
T* () Tj
T* (Alfredo: y en aspecto general que hace la funcion Grover3 en este caso? a demás que referencias puedo buscar para) Tj
T* (comprenderlo mejor?) Tj
T* () Tj
T* (Chatsonic: La función `Grover3` es una implementación del algoritmo de búsqueda de Grover, que es utilizado para buscar una) Tj
T* (solución en una base de datos no estructurada de manera más eficiente que los métodos clásicos. En este caso, la función) Tj
T* (`Grover3` se aplica a los primeros 24 qubits del circuito cuántico `qc3`. ) Tj
T* () Tj
T* (La función busca una solución a partir de una lista de posibles soluciones utilizando una estrategia de búsqueda cuántica. En) Tj
T* (términos generales, el algoritmo de Grover se puede entender como una rotación en el espacio de estado de los qubits que lleva) Tj
T* (la amplitud de la solución deseada a un estado de mayor amplitud, lo que aumenta la probabilidad de medir la solución correcta) Tj
T* (al final del algoritmo. ) Tj
T* () Tj
T* (Para comprender mejor el algoritmo de Grover y su implementación en Qiskit, puede consultar la documentación oficial de) Tj
T* (Qiskit y el libro "Quantum Computation and Quantum Information" de Nielsen y Chuang. También existen numerosos) Tj
T* (recursos en línea y tutoriales que explican el algoritmo en detalle.) Tj
T* () Tj
T* (Alfredo: explicame como a un niño de 5 años lo que Nielsen y Chuang desarrollan sobre el algoritmo de Grover) Tj
T* () Tj
T* (Chatsonic: ¡Claro! El algoritmo de Grover es como encontrar la aguja en un pajar, pero mucho más rápido. Imagina que tienes) Tj
T* (una caja llena de pelotas, algunas son rojas y otras son azules, pero solo quieres encontrar las pelotas rojas. En lugar de buscar) Tj
T* (aleatoriamente en la caja, el algoritmo de Grover te ayuda a encontrar las pelotas rojas más rápido. Funciona como una linterna) Tj
T* (que ilumina solo las pelotas rojas, haciéndolas más fáciles de encontrar. Este algoritmo es muy útil para buscar cosas en) Tj
T* (grandes bases de datos y encontrar soluciones a problemas complejos.) Tj
T* () Tj
T* (Alfredo: Explicame la funcionalidad general del código que te proporcioné anteriormente ¿Cuál es su proposito general?) Tj
T* () Tj
T* (Chatsonic: El código que me proporcionaste anteriormente es un fragmento de un programa en lenguaje de programación de) Tj
T* (circuitos cuánticos Qiskit, el cual tiene como propósito la implementación del algoritmo de Grover para la búsqueda de) Tj
T* (soluciones en problemas de optimización. El código utiliza una serie de compuertas cuánticas como la compuerta `Hadamard`,) Tj
T* (la compuerta controlada `MCXGate`, y las compuertas de inversión de fase para preparar el estado inicial del sistema y aplicar) Tj
T* (la búsqueda cuántica. El algoritmo de Grover en este caso se utiliza para encontrar soluciones óptimas de un conjunto de reglas) Tj
T* (en un problema de optimización. El código es una implementación de un algoritmo cuántico para la resolución de problemas y) Tj
T* (puede ser utilizado como base para la implementación de algoritmos más complejos en el futuro.) Tj
T* () Tj
T* () Tj
ET
endstream
endobj
1 0 obj
<</Type /Pages
/Kids [3 0 R ]
/Count 1
>>
endobj
5 0 obj
<<
/Type /Font
/BaseFont /Helvetica
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
6 0 obj
<<
/Type /Font
/BaseFont /Helvetica-Bold
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
7 0 obj
<<
/Type /Font
/BaseFont /Helvetica-Oblique
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
8 0 obj
<<
/Type /Font
/BaseFont /Helvetica-BoldOblique
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
9 0 obj
<<
/Type /Font
/BaseFont /Courier
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
10 0 obj
<<
/Type /Font
/BaseFont /Courier-Bold
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
11 0 obj
<<
/Type /Font
/BaseFont /Courier-Oblique
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
12 0 obj
<<
/Type /Font
/BaseFont /Courier-BoldOblique
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
13 0 obj
<<
/Type /Font
/BaseFont /Times-Roman
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
14 0 obj
<<
/Type /Font
/BaseFont /Times-Bold
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
15 0 obj
<<
/Type /Font
/BaseFont /Times-Italic
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
16 0 obj
<<
/Type /Font
/BaseFont /Times-BoldItalic
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
17 0 obj
<<
/Type /Font
/BaseFont /ZapfDingbats
/Subtype /Type1
/FirstChar 32
/LastChar 255
>>
endobj
18 0 obj
<<
/Type /Font
/BaseFont /Symbol
/Subtype /Type1
/FirstChar 32
/LastChar 255
>>
endobj
2 0 obj
<<
/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]
/Font <<
/F1 5 0 R
/F2 6 0 R
/F3 7 0 R
/F4 8 0 R
/F5 9 0 R
/F6 10 0 R
/F7 11 0 R
/F8 12 0 R
/F9 13 0 R
/F10 14 0 R
/F11 15 0 R
/F12 16 0 R
/F13 17 0 R
/F14 18 0 R
>>
/XObject <<
>>
>>
endobj
19 0 obj
<<
/Producer (jsPDF 2.5.1)
/CreationDate (D:20230321164114-04'00')
>>
endobj
20 0 obj
<<
/Type /Catalog
/Pages 1 0 R
/OpenAction [3 0 R /FitH null]
/PageLayout /OneColumn
>>
endobj
xref
0 21
0000000000 65535 f 
0000015970 00000 n 
0000017787 00000 n 
0000000015 00000 n 
0000000152 00000 n 
0000016027 00000 n 
0000016152 00000 n 
0000016282 00000 n 
0000016415 00000 n 
0000016552 00000 n 
0000016675 00000 n 
0000016804 00000 n 
0000016936 00000 n 
0000017072 00000 n 
0000017200 00000 n 
0000017327 00000 n 
0000017456 00000 n 
0000017589 00000 n 
0000017691 00000 n 
0000018035 00000 n 
0000018121 00000 n 
trailer
<<
/Size 21
/Root 20 0 R
/Info 19 0 R
/ID [ <46E5FC504BA0F421DF3F90BF1DDF78D6> <46E5FC504BA0F421DF3F90BF1DDF78D6> ]
>>
startxref
18225
%%EOF